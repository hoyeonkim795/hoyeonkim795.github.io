---
title: "[OS] 은행원 알고리즘"
date: 2021-01-27 04:32:30 +0800
categories: [Computer Science, Operating System]
tags: [deadlock, 교착상태, 교착상태 회피, 은행원 알고리즘]  
---

# 은행원 알고리즘

은행가 알고리즘은 자원의 할당 허용 여부를 결정하기 전에 미리 결정된 모든 자원의 최대 가능한 할당량을 시뮬레이션하여 안전 여부를 검사한다. 그런 다음 대기 중인 다른 모든 활동의 교착 상태 가능성을 조사하여 "안정 상태" 여부를 검사 확인한다.

여기서 은행가 알고리즘은 다음 자료구조 들이 필요하다.

- Availabe: 각 형태별로 사용 가능한 자원 수 (사용 가능량)을 표시하는 길이가 m 인 벡터이다. Available[j] = k 이면, j 번째 자원을 k개 사용할 수 있다는 의미이다.

- Max: 각 프로세스 자원의 최대 요청량(최대 요구량)을 표시하는 n * m 행렬이다. Max[i,j] = k 이면, 프로세스 Pi는 자원 Rj를 최대 k개 까지 요청할 수 있다는 의미이다. 

- Allocation : 현재 각 프로세스에 할당되어 있는 각 형태의 자원 수(현재 할당량)을 정의 하는 n*m 행렬이다. Allocation[i, j] = k 이면, 프로세스 Pi는 자원 Rj를 k 개 할당받고 있다는 의미이다.

- Need : 각 프로세스에 남아 있는 자원 요청(추가 요구량)을 표시하는 n*m 행렬이다. Need[i,j] = k 이면 프로세스 Pi는 자신의 작업을 종료하려고 Rj를 k개 더 필요하다는 의미이다.



프로세스 Pi 가 여기서 자원을 요청하게 되면 다음과 같은 동작이 일어난다. 

---

- 1단계 :  Request(i)≤ Need(i)이면 2단계로 이동하고 그렇지 않으면 프로세스가 최대 요청치를 초과하기 때문에 오류 상태가 된다.
- 2단계: Request ≤ Available 이면 3단계로 이동하고, 그렇지 않으면 자원이 부족하기 때문에 Pi는 대기한다.
- 3단계: 시스템은 상태를 다음과 같이 수정하여 요청된 자원을 프로세스 Pi에 할당한다.

    Available = Available - Request(i);

    Allocation(i) = Allocation(i) + Request(i);

    Need(i) = Need(i) - Request(i);

---

그리고 이제 안정 상태인지, 불안정 상태인지 검사한다. 다음 과정으로 수행된다.

- 1단계 : Work와 Finish를 각각 길이가 m과 n인 벡터라고 하자. Work = Available, Finish[i] = False, i = 1,2, ... n 으로 초기화 한다.
- 2단계 : 다음 조건을 만족하는 i 값을 찾는다. i 값이 없으면 4단계로 이동한다.

    Finish[i] == False

    Need(i) ≤ Work

- 3단계 : 다음을 수행하고 2단계로 이동한다.

    Work = Work + Allocation(i)

    Finish[i] = True

- 4단계 : 모든 i 에 대하여 Finish[i] == True이면 시스템은 안정상태이다.

![Untitled.png](\assets\img\은행원알고리즘\Untitled.png)

위의 예시에서는 P2 → P4 → P1 → P3 순서일때 안정상태에 있다.

이렇게 은행가 알고리즘은 교착 상태를 회피하려고 교착 상태가 일어나지 않을 때만 작업을 진행시킨다. 그러나 다음 단점이 있다.

- 일정하게 남아있는 자원 수를 파악하기가 매우 어렵다.
- 다중 프로그래밍 시스템에서는 사용자 수가 항상 변한다.
- **교착 상태 회피 알고리즘을 실행하면 시스템 과부하가 증가한다.**
- 프로세스는 자원을 보유한 상태로 끝낼 수 없다.
- 항상 불안정 상태를 방지해야하므로 자원 이용도가 낮다.

